// Generated by CoffeeScript 1.6.3
var Distribution, crypto, fs, glob, mime, mkdirp, path, _,
  __hasProp = {}.hasOwnProperty;

fs = require('fs');

path = require('path');

crypto = require('crypto');

mime = require('mime');

mkdirp = require('mkdirp');

glob = require('glob');

_ = require('underscore');

Distribution = (function() {
  function Distribution(options) {
    if (options == null) {
      options = {};
    }
    this.logger = options.logger || console;
    this.assetDir = options.assetDir || 'assets';
    this.rootUrl = options.rootUrl || '/';
    this.processors = options.processors || {};
    this.assets = options.assets || {};
  }

  Distribution.prototype.get = function(key) {
    return this.assets[key];
  };

  Distribution.prototype.make = function(key, filename, options) {
    var file, files, opts, _i, _key, _len, _results;
    if (options == null) {
      options = {};
    }
    if (key == null) {
      return;
    }
    if (_.isObject(key)) {
      for (_key in key) {
        if (!__hasProp.call(key, _key)) continue;
        opts = key[_key];
        if (_.isObject(opts)) {
          this.make(_key, opts.file, opts);
        } else {
          this.make(_key, opts);
        }
      }
      return;
    }
    if (options.url != null) {
      this.assets[key] = options.url;
      return true;
    }
    if (filename == null) {
      filename = key;
    }
    files = glob.sync(filename, {
      mark: true
    });
    if (options.assetDir == null) {
      options.assetDir = this.assetDir;
    }
    if (options.rootUrl == null) {
      options.rootUrl = this.rootUrl;
    }
    if (files.length === 1 && files[0].substr(-1) !== '/') {
      return this.process(key, files[0], options);
    } else if (files.length > 0) {
      _results = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        if (file.substr(-1) !== '/') {
          _results.push(this.process(file, file, options));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    } else {
      if (this.logger.error) {
        return this.logger.error("Bad pattern: '" + filename + "'");
      }
    }
  };

  Distribution.prototype.process = function(key, filename, options) {
    var basename, content, err, extname, md5, mimetype, name, url;
    if (options == null) {
      options = {};
    }
    extname = path.extname(filename);
    basename = path.basename(filename, extname);
    mimetype = options.mimetype || mime.lookup(extname);
    if (!fs.existsSync(filename)) {
      if (this.logger.error) {
        this.logger.error("File '" + filename + "' not exists");
      }
      return false;
    }
    try {
      content = fs.readFileSync(filename);
    } catch (_error) {
      err = _error;
      if (this.logger.error) {
        this.logger.error(err);
      }
      return false;
    }
    if (this.processors[mimetype] != null) {
      content = this.processors[mimetype](this, filename, content, options);
    }
    name = basename;
    if (options.hash !== false) {
      md5 = crypto.createHash('md5').update(content).digest('hex');
      name = "" + name + "-" + md5;
    }
    name = "" + name + extname;
    if (this.assetLocal(options.assetDir, name, content) === false) {
      return false;
    }
    url = path.join(options.rootUrl, name);
    this.assets[key] = url;
    if (this.logger.info) {
      this.logger.info("Created asset '" + url + "' for key '" + key + "'");
    }
    return true;
  };

  Distribution.prototype.assetLocal = function(assetDir, filename, content) {
    var dest, err;
    dest = path.join(assetDir, filename);
    try {
      mkdirp.sync(assetDir);
      return fs.writeFileSync(dest, content);
    } catch (_error) {
      err = _error;
      if (this.logger.error) {
        this.logger.error(err);
      }
      return false;
    }
  };

  Distribution.prototype.addProcessor = function(mimetype, processor) {
    return this.processors[mimetype] = processor;
  };

  return Distribution;

})();

module.exports = Distribution;
