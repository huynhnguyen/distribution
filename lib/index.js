// Generated by CoffeeScript 1.6.3
var Distribution, crypto, cssProcessor, fs, glob, mime, mkdirp, path, _,
  __hasProp = {}.hasOwnProperty;

fs = require('fs');

path = require('path');

crypto = require('crypto');

mime = require('mime');

mkdirp = require('mkdirp');

glob = require('glob');

_ = require('underscore');

cssProcessor = require('./processors/css');

console.log(cssProcessor);

Distribution = (function() {
  function Distribution(options) {
    if (options == null) {
      options = {};
    }
    this.logger = options.logger || console;
    this.assetDir = options.assetDir || 'assets';
    this.rootUrl = options.rootUrl || '/';
    this.processors = options.processors || {};
    this.assets = options.assets || {};
  }

  Distribution.prototype.get = function(key) {
    return this.assets[key];
  };

  Distribution.prototype.make = function(key, filename, options) {
    var file, files, opts, _i, _key, _len, _results;
    if (_.isObject(key)) {
      for (_key in key) {
        if (!__hasProp.call(key, _key)) continue;
        opts = key[_key];
        this.make(_key, opts.file, opts);
      }
      return;
    }
    if (filename == null) {
      filename = key;
    }
    files = glob.sync(filename, {
      mark: true
    });
    if (files.length === 1 && files[0].substr(-1) !== '/') {
      options = options || {};
      if (options.assetDir == null) {
        options.assetDir = this.assetDir;
      }
      if (options.rootUrl == null) {
        options.rootUrl = this.rootUrl;
      }
      return this.process(key, files[0], options);
    } else if (files.length > 1) {
      _results = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        _results.push(this.make(file, file, options));
      }
      return _results;
    } else {
      if (this.logger.error) {
        this.logger.error("Bad pattern: '" + filename + "'");
      }
      return false;
    }
  };

  Distribution.prototype.process = function(key, filename, options) {
    var basename, content, extname, md5, mimetype, name, url;
    if (options == null) {
      options = {};
    }
    extname = path.extname(filename);
    basename = path.basename(filename, extname);
    mimetype = options.mimetype || mime.lookup(extname);
    if (!fs.existsSync(filename)) {
      if (this.logger.error) {
        this.logger.error("File '" + filename + "' not exists");
      }
      return;
    }
    content = fs.readFileSync(filename);
    if (this.processors[mimetype] != null) {
      content = this.processors[mimetype](this, filename, content, options);
    }
    name = basename;
    if (options.hash !== false) {
      md5 = crypto.createHash('md5').update(content).digest('hex');
      name = "" + name + "-" + md5;
    }
    name = "" + name + extname;
    this.assetLocal(options.assetDir, name, content);
    url = path.join(options.rootUrl, name);
    this.assets[key] = url;
    if (this.logger.info) {
      this.logger.info("Created asset '" + dest + "' for key '" + key + "'");
    }
    return true;
  };

  Distribution.prototype.assetLocal = function(assetDir, filename, content) {
    var dest;
    mkdirp.sync(assetDir);
    dest = path.join(assetDir, filename);
    return fs.writeFileSync(dest, content);
  };

  Distribution.prototype.addProcessor = function(mimetype, processor) {
    return this.processors[mimetype] = processor;
  };

  return Distribution;

})();

module.exports = new Distribution({
  processors: {
    'text/css': cssProcessor
  }
});

module.exports.Distribution = Distribution;

module.exports.cssProcessor = cssProcessor;
